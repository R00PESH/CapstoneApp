package training.iqgateway.service.impl;

import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.query.Criteria;
import org.springframework.data.mongodb.core.query.Query;
import org.springframework.stereotype.Service;

import training.iqgateway.model.DoctorEO;
import training.iqgateway.model.DoctorEO.Review;
import training.iqgateway.repo.DoctorRepository;
import training.iqgateway.service.DoctorService;

@Service
public class DoctorServiceImpl implements DoctorService {
	
	@Autowired
	private DoctorRepository doctorRepo;;
	
	@Autowired
	private MongoTemplate mongoTemplate;

	@Override
	public DoctorEO createDoctor(DoctorEO doctor) {
		// TODO Auto-generated method stub
		return doctorRepo.save(doctor);
	}

	@Override
	public DoctorEO getDoctorById(String id) {
		// TODO Auto-generated method stub
		return doctorRepo.findByDocId(id);
				//.orElseThrow(() -> new RuntimeException("Doctor not found with id: " + id));
	}

	@Override
	public List<DoctorEO> getAllDoctors() {
		// TODO Auto-generated method stub
		return doctorRepo.findAll();
	}

	@Override
	public DoctorEO updateDoctor(String id, DoctorEO doctor) {
		DoctorEO existing = getDoctorById(id);
        if (existing == null) return null;
        doctor.setId(id);
        updateAvgRating(doctor); // recalc rating
        return doctorRepo.save(doctor);
	}

	@Override
	public void deleteDoctor(String id) {
		// TODO Auto-generated method stub
		DoctorEO existing = getDoctorById(id);
		if (existing == null) return;
		doctorRepo.delete(existing);

	}
	
	 @Override
	    public List<DoctorEO> filterDoctors(
	            String docId, Integer hosId, String specialization, String availabilityStatus,
	            String licenseNumber, String qualification, String name, double yearsOfExperience
	    ) {
	        List<Criteria> criteriaList = new ArrayList<>();
	        if (docId != null) criteriaList.add(Criteria.where("docId").is(docId));
	        if (hosId != null) criteriaList.add(Criteria.where("hosId").is(hosId));
	        if (specialization != null) criteriaList.add(Criteria.where("specialization").is(specialization));
	        if (availabilityStatus != null) criteriaList.add(Criteria.where("availabilityStatus").is(availabilityStatus));
	        if (licenseNumber != null) criteriaList.add(Criteria.where("licenseNumber").is(licenseNumber));
	        if (qualification != null) criteriaList.add(Criteria.where("qualification").is(qualification));
	        if (name != null) criteriaList.add(Criteria.where("name").is(name));
	        if (yearsOfExperience != 0.0) {
	            try {
	          
	                criteriaList.add(Criteria.where("years_of_practice").gte(yearsOfExperience));
	            } catch (NumberFormatException e) {
	                // Handle the case where yearsOfExperience is not a valid number
	            }
	        }
	        Query query = new Query();
	        if (!criteriaList.isEmpty())
	            query.addCriteria(new Criteria().andOperator(criteriaList));
	        return mongoTemplate.find(query, DoctorEO.class);
	    }

	 @Override
	    public DoctorEO addReview(String doctorId, DoctorEO.Review review) {
	        DoctorEO doctor = getDoctorById(doctorId);
	        if (doctor == null) return null;
	        if (doctor.getReviews() == null) doctor.setReviews(new ArrayList<>());
	        doctor.getReviews().add(review);
	        updateAvgRating(doctor);
	        return doctorRepo.save(doctor);
	    }
	    private void updateAvgRating(DoctorEO doctor) {
	        List<DoctorEO.Review> reviews = doctor.getReviews();
	        if (reviews != null && !reviews.isEmpty()) {
	            double avg = reviews.stream().mapToDouble(DoctorEO.Review::getRating).average().orElse(0.0);
	            doctor.setRating(Math.round(avg * 10.0) / 10.0);
	        } else {
	            doctor.setRating(0.0);
	        }
	    }

}
